let effect @ { Eff, ? } = import! std.effect
let { Lift, run_lift, lift, ? } = import! std.effect.lift
let { wrap } = import! std.applicative
let { Reporting } = import! lancer.reporting
let { ObjectRef, ObjectArg, ? } = import! lancer.transaction.builder.types
let { find_map } = import! std.foldable
let { unwrap } = import! std.option
let { is_empty } = import! std.array
let { (<|), (<<) } = import! std.function
let { TransactionBlockResponse, ObjectChange, ? } = import! lancer.rpc.types
let { TypeTag, StructTag, ? } = import! lancer.sui.types
let { SuiAddress, ? } = import! lancer.sui.sui_address
let { unwrap_ok, ? } = import! std.result
let { parse } = import! lancer.parse

let {
    TestCluster,
    generate_keypair,
    execute_tx,
    get_coins,
    commit_preparation,
    commit_demonstration,
} = import! lancer.effect.test_cluster

let {
    load_directory,
    compile
} = import! lancer.effect.compiler

let {
    u8,
    u16,
    u32,
    u64,
    bool,
    address,
    object_ref,
    publish_upgradeable,
    publish_immutable,
    move_call,
    pay,
} = import! lancer.effect.transaction_builder

load_directory "../../sui/dummy_pool"
do { bytes, dep_ids } = compile

do admin = generate_keypair

do r = execute_tx 500000000 admin (
    publish_immutable bytes dep_ids
)

let package_id = unwrap (find_map (\x ->
    match x with
    | Published { package_id, ? } -> Some package_id
    | _ -> None) r.object_changes)
let (state_id, state_version) = unwrap (find_map (\x ->
    match x with
    | Created {
        object_id,
        version,
        digest,
        object_type = { 
            address,
            module = "dummy_pool",
            name = "DummyPool",
            type_params,
        }, ? } ->
            if address == package_id && is_empty type_params then
                Some (object_id, version)
            else None
    | _ -> None) r.object_changes)

let some_coin_struct: StructTag = {
    address = package_id,
    module = "some_coin",
    name = "SOME_COIN",
    type_params = [],
}

let some_coin_type: TypeTag = Struct some_coin_struct

let dummy_pool_coin_struct: StructTag = {
    address = package_id,
    module = "dummy_pool",
    name = "DUMMY_POOL",
    type_params = [],
}

let dummy_pool_coin_type: TypeTag = Struct dummy_pool_coin_struct

let sui_framework = unwrap_ok (parse "0x0000000000000000000000000000000000000000000000000000000000000002")

let some_coin_object_ref: ObjectRef = unwrap (find_map (\x ->
    match x with
    | Created {
        object_id,
        version,
        digest,
        object_type = { 
            address,
            module = "coin",
            name = "Coin",
            type_params,
        }, ? } -> if address == sui_framework && type_params == [some_coin_type] then Some (object_id, version, digest) else None
    | _ -> None) r.object_changes)

do r = execute_tx 500000000 admin (
    do state_arg = object_ref <| SharedObject {
        id = state_id,
        initial_shared_version = state_version,
        mutable = True,
    }
    do price = u64 10000
    move_call package_id "dummy_pool" "create_vault" [ some_coin_type ] [
        state_arg,
        price
    ]
)

commit_preparation
commit_demonstration Public
