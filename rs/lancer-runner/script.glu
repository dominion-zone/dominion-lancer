let io @ { ? } = import! std.io
let { ? } = import! lancer.sui.digest
let { object_change_kind, ObjectChange, ? } = import! lancer.rpc
let { ? } = import! std.byte
let array = import! std.array
let tx = import! lancer.transaction
let c = import! lancer.compiler
let { start, execute } = import! lancer
let { find_map } = import! std.foldable
let { unwrap } = import! std.option
let { is_empty } = import! std.array
let { StructTag } = import! lancer.sui.types
let { ObjectRef, ? } = import! lancer.transaction.types

do p = c.compile "../../sui/dummy_pool"
do b = tx.builder
tx.publish_immutable b (c.bytes p) (c.dep_ids p)
do t = tx.finish b
start
io.print "Started\n"
do r = execute t
io.print "Executed\n"
let package_id = unwrap (find_map (\x ->
    match x with
    | Published { package_id, ? } -> Some package_id
    | _ -> None) r.object_changes)
let state_ref: ObjectRef = unwrap (find_map (\x ->
    match x with
    | Created {
        object_id,
        version,
        digest,
        object_type = { 
            address = package_id,
            module = "dummy_pool",
            name = "DummyPool",
            type_params,
        }, ? } -> if is_empty type_params then Some (object_id, version, digest) else None
    | _ -> None) r.object_changes)

let some_coin_type: StructTag = {
    address = package_id,
    module = "some_coin",
    name = "SOME_COIN",
    type_params = [],
}

io.print (show state_ref)