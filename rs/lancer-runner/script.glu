let io @ { ? } = import! std.io
let { ? } = import! lancer.sui.digest
let { ? } = import! lancer.sui.sui_address
let { object_change_kind, ObjectChange, ? } = import! lancer.rpc
let { ? } = import! std.byte
let array = import! std.array
let tx = import! lancer.transaction
let c = import! lancer.compiler
let { start, execute, generate_keypair } = import! lancer
let { find_map } = import! std.foldable
let { unwrap } = import! std.option
let { is_empty } = import! std.array
let { TypeTag } = import! lancer.sui.types
let { ObjectRef, ObjectArg, ? } = import! lancer.transaction.types
let { ? } = import! lancer.sui.types
let { parse } = import! lancer.parse

do p = c.compile "../../sui/dummy_pool"
do b = tx.builder
tx.publish_immutable b (c.bytes p) (c.dep_ids p)
do t = tx.finish b
start
io.print "Started\n"
do r = execute t None
io.print "Executed\n"
let package_id = unwrap (find_map (\x ->
    match x with
    | Published { package_id, ? } -> Some package_id
    | _ -> None) r.object_changes)
let (state_id, state_version) = unwrap (find_map (\x ->
    match x with
    | Created {
        object_id,
        version,
        digest,
        object_type = { 
            address = package_id,
            module = "dummy_pool",
            name = "DummyPool",
            type_params,
        }, ? } -> if is_empty type_params then Some (object_id, version) else None
    | _ -> None) r.object_changes)

let some_coin_type: TypeTag = Struct {
    address = package_id,
    module = "some_coin",
    name = "SOME_COIN",
    type_params = [],
}

do sui_framework = parse "0x0000000000000000000000000000000000000000000000000000000000000002"

let some_coin_object_ref: ObjectRef = unwrap (find_map (\x ->
    match x with
    | Created {
        object_id,
        version,
        digest,
        object_type = { 
            address,
            module = "coin",
            name = "Coin",
            type_params,
        }, ? } -> if address == sui_framework && type_params == [some_coin_type] then Some (object_id, version, digest) else None
    | _ -> None) r.object_changes)

do b = tx.builder
do state_ref = tx.object_ref b (SharedObject {
    id = state_id,
    initial_shared_version = state_version,
    mutable = True,
})
do price = tx.u64 b 10000
tx.move_call b package_id "dummy_pool" "create_vault" [ some_coin_type ] [
    state_ref,
    price
]
do t = tx.finish b
do r = execute t None
// io.print (show r.object_changes)

do user = generate_keypair
do b = tx.builder
tx.pay b [some_coin_object_ref] [10000000] [user]
do t = tx.finish b
do r = execute t None
io.print (show r)
