let io @ { ? } = import! std.io
let { ? } = import! lancer.sui.digest
let { ? } = import! lancer.sui.sui_address
let { object_change_kind, ObjectChange, ? } = import! lancer.rpc
let { ? } = import! std.byte
let array = import! std.array
let tx = import! lancer.transaction
let c = import! lancer.compiler
let { current_wallet, start, execute, generate_keypair, get_coins, commit } = import! lancer
let { find_map } = import! std.foldable
let { unwrap } = import! std.option
let { is_empty } = import! std.array
let { TypeTag, StructTag } = import! lancer.sui.types
let { ObjectRef, ObjectArg, ? } = import! lancer.transaction.types
let { ? } = import! lancer.sui.types
let { parse } = import! lancer.parse
let { assert } = import! std.assert

do p = c.compile "../../sui/dummy_pool"
do b = tx.builder
tx.publish_immutable b (c.bytes p) (c.dep_ids p)
do t = tx.finish b
start
io.print ("Preparation: " ++ (show (unwrap (current_wallet ()))) ++ "\n")
do r = execute t None
let package_id = unwrap (find_map (\x ->
    match x with
    | Published { package_id, ? } -> Some package_id
    | _ -> None) r.object_changes)
let (state_id, state_version) = unwrap (find_map (\x ->
    match x with
    | Created {
        object_id,
        version,
        digest,
        object_type = { 
            address,
            module = "dummy_pool",
            name = "DummyPool",
            type_params,
        }, ? } ->
            if address == package_id && is_empty type_params then
                Some (object_id, version)
            else None
    | _ -> None) r.object_changes)

let some_coin_struct: StructTag = {
    address = package_id,
    module = "some_coin",
    name = "SOME_COIN",
    type_params = [],
}

let some_coin_type: TypeTag = Struct some_coin_struct

do sui_framework = parse "0x0000000000000000000000000000000000000000000000000000000000000002"

let some_coin_object_ref: ObjectRef = unwrap (find_map (\x ->
    match x with
    | Created {
        object_id,
        version,
        digest,
        object_type = { 
            address,
            module = "coin",
            name = "Coin",
            type_params,
        }, ? } -> if address == sui_framework && type_params == [some_coin_type] then Some (object_id, version, digest) else None
    | _ -> None) r.object_changes)

do b = tx.builder
do state_ref = tx.object_ref b (SharedObject {
    id = state_id,
    initial_shared_version = state_version,
    mutable = True,
})
do price = tx.u64 b 10000
tx.move_call b package_id "dummy_pool" "create_vault" [ some_coin_type ] [
    state_ref,
    price
]
do t = tx.finish b
do r = execute t None
let (vault_id, vault_version) = unwrap (find_map (\x ->
    match x with
    | Created {
        object_id,
        version,
        digest,
        object_type = { 
            address,
            module = "dummy_pool",
            name = "Vault",
            type_params,
        }, ? } ->
            if address == package_id && type_params == [some_coin_type] then
                Some (object_id, version)
            else None
    | _ -> None) r.object_changes)
// io.print (show r.object_changes)

do user = generate_keypair
do b = tx.builder
tx.pay b [some_coin_object_ref] [10000000] [user]
do t = tx.finish b
do r = execute t None
do coins = get_coins some_coin_struct user
let _ = assert(array.len coins == 1)
let coin = array.index coins 0


do b = tx.builder
do state_arg = tx.object_ref b (SharedObject {
    id = state_id,
    initial_shared_version = state_version,
    mutable = True,
})
do vault_arg = tx.object_ref b (SharedObject {
    id = vault_id,
    initial_shared_version = vault_version,
    mutable = True,
})
do coin_arg = tx.object_ref b (ImmOrOwnedObject (coin.coin_object_id, coin.version, coin.digest))
tx.move_call b package_id "dummy_pool" "deposit" [ some_coin_type ] [
    state_arg,
    vault_arg,
    coin_arg
]
do t = tx.finish b
do r = execute t (Some user)
// io.print (show r)
commit
io.print ("Hacking: " ++ (show (unwrap (current_wallet ()))) ++ "\n")
