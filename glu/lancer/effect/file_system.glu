let effect @ { Arr, Eff, inject_rest, ? } = import! std.effect
let { Lift, run_lift, lift, ? } = import! std.effect.lift
let { (<|), (<<) } = import! std.function
let { wrap } = import! std.applicative
let { State, run_state, get, put, modify } = import! std.effect.state
let io @ { IO } = import! std.io
let array = import! std.array
let { Functor } = import! std.functor
let { components, Component, join, ? } = import! std.path
let { any } = import! std.foldable


type FileSystem r a =
    | ReadFileToString : String -> FileSystem r String
    .. r

let read_file_to_string file_path : String -> Eff [| file_system : FileSystem | r |] String =
    Impure (convert_effect! file_system (ReadFileToString file_path)) Pure

#[inline(never)]
let extract_file_system x : [| file_system : FileSystem | r |] a -> FileSystem r a = convert_variant! x

let run_file_system working_dir eff =
    let working_dir = join working_dir "input"
    let escape_path path =
        let cs = components path
        if any (\c -> c == ParentDir || c == RootDir) cs then
            lift <| io.throw "Invalid file path: cannot contain '..' or '/'"
        else
            wrap <| join working_dir path
    let loop ve =
        match ve with
        | Pure value -> wrap value
        | Impure e f ->
            match extract_file_system e with
            | ReadFileToString path ->
                do path = escape_path path
                do data = lift <| io.read_file_to_string path
                loop <| f data
            | rest ->
                Impure (inject_rest rest) (loop << f)
    loop eff

{
    FileSystem,
    read_file_to_string,
    run_file_system,
}