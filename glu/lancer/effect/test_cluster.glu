let effect @ { Eff, inject_rest, run_pure, ? } = import! std.effect
let prim = import! lancer.test_cluster.prim
let tc = import! lancer.test_cluster
let tw @ { TempWallet } = import! lancer.temp_wallet
let { Lift, run_lift, lift, ? } = import! std.effect.lift
let { (<|), (<<) } = import! std.function
let { wrap } = import! std.applicative
let { State, exec_state, get, put } = import! std.effect.state
let r @ { ReportBuilder, FinalReport, Log, SystemLog, ? } = import! lancer.report
let io @ { IO } = import! std.io
let { Transaction } = import! lancer.transaction
let { TransactionBlockResponse } = import! lancer.rpc
let { SuiAddress } = import! lancer.sui.sui_address
let { StructTag } = import! lancer.sui.types
let { Coin } = import! lancer.rpc.types
let { Reporting } = import! lancer.reporting
let { TransactionBuilder, run_transaction_builder, ? } = import! lancer.effect.transaction_builder
let { Logger, log, ? } = import! lancer.effect.logger

type TestCluster r a =
    | GenerateKeypair : TestCluster r SuiAddress
    | ExecuteTx : forall x . Int -> SuiAddress -> Array SuiAddress
        -> Eff [| transaction_builder: TransactionBuilder | r |] x
        -> TestCluster r TransactionBlockResponse
    | GetCoins : StructTag -> SuiAddress -> TestCluster r (Array Coin)
    | GetBalance : StructTag -> SuiAddress -> TestCluster r Int
    | CommitPreparation : Array SuiAddress -> TestCluster r ()
    | CommitDemonstration : Reporting -> TestCluster r ()
    .. r

let generate_keypair : Eff [| test_cluster : TestCluster | r |] SuiAddress =
    Impure (convert_effect! test_cluster GenerateKeypair) Pure

let execute_tx gas_budget sender tx_building
    : forall x . Int
    -> SuiAddress
    -> Eff [| transaction_builder: TransactionBuilder | r |] x
    -> Eff [| test_cluster : TestCluster | r |] TransactionBlockResponse =
    let r : TestCluster r TransactionBlockResponse = ExecuteTx gas_budget sender [] tx_building
    Impure (convert_effect! test_cluster r) Pure

let get_coins coin_type owner
    : StructTag -> SuiAddress -> Eff [| test_cluster : TestCluster | r |] (Array Coin) =
    Impure (convert_effect! test_cluster (GetCoins coin_type owner)) Pure

let get_balance coin_type owner
    : StructTag -> SuiAddress -> Eff [| test_cluster : TestCluster | r |] Int =
    Impure (convert_effect! test_cluster (GetBalance coin_type owner)) Pure

let commit_preparation retaining_keys : Array SuiAddress -> Eff [| test_cluster : TestCluster | r |] () =
    Impure (convert_effect! test_cluster (CommitPreparation retaining_keys)) Pure

let commit_demonstration reporting
    : Reporting -> Eff [| test_cluster : TestCluster | r |] () =
    Impure (convert_effect! test_cluster (CommitDemonstration reporting)) Pure

#[inline(never)]
let extract_test_cluster x : [| test_cluster : TestCluster | r |] a -> TestCluster r a = convert_variant! x

type Data = {
    cluster: tc.TestCluster,
    report_builder: ReportBuilder,
    temp_wallet: TempWallet,
}

let run_test_cluster cluster temp_wallet working_dir eff =
    let loop ve : Eff [|
            test_cluster: TestCluster,
            lift : Lift IO,
            state: State Data,
            logger: Logger Log | r |] a
        -> Eff [|
            lift : Lift IO,
            state: State Data,
            logger: Logger Log | r |] a =
        match ve with
        | Pure value -> wrap value
        | Impure e f ->
            match extract_test_cluster e with
            | GenerateKeypair ->
                do current_state = get
                do address = tw.generate_keypair current_state.temp_wallet
                log <| System <| KeypairGenerated { address }
                loop <| f address
            | ExecuteTx gas_budget sender additional_signers tx ->
                do tx = run_transaction_builder working_dir tx
                do current_state = get
                do tx_block_response = tc.execute_tx current_state.cluster current_state.temp_wallet tx gas_budget sender additional_signers
                log <| System <| TxExecuted { dummy = 1 } // tx tx_block_response
                loop <| f tx_block_response
            | GetCoins coin_type owner ->
                do current_state = get
                do coins = tc.get_coins current_state.cluster coin_type owner
                loop <| f coins
            | GetBalance coin_type owner ->
                do current_state = get
                do balance = tc.get_balance current_state.cluster coin_type owner
                loop <| f balance
            | CommitPreparation retaining_keys ->
                do current_state = get
                tw.retain_keys current_state.temp_wallet retaining_keys
                match current_state.report_builder with
                | Nothing ->
                    do sql = tc.dump_db current_state.cluster
                    put <| {
                        cluster = current_state.cluster,
                        report_builder = Preparation {
                            sql,
                            keys = tw.get_keys current_state.temp_wallet,
                        },
                        temp_wallet = current_state.temp_wallet,
                    }
                    log <| System <| PreparationCommited { retaining_keys }
                    loop <| f ()
                | _ -> lift <| io.throw "Invalid state for commit preparation"
            | CommitDemonstration reporting ->
                do current_state = get
                match current_state.report_builder with
                | Preparation p ->
                    do sql = tc.dump_db current_state.cluster
                    tc.stop current_state.cluster
                    put <| {
                        cluster = current_state.cluster,
                        report_builder = Final {
                            preparation = p,
                            demonstration = {
                                sql,
                                keys = tw.get_keys current_state.temp_wallet,
                            },
                        },
                        temp_wallet = current_state.temp_wallet,
                    }
                    log <| System <| DemonstrationCommited { reporting }
                    loop <| f ()
                | _ -> lift <| io.throw "Invalid state for commit demonstration"
            | rest ->
                Impure (inject_rest rest) (loop << f)

    let initial_state = {
        cluster,
        report_builder = Nothing,
        temp_wallet,
    }
    do s = exec_state initial_state <| loop eff
    r.build s.report_builder

{
    TestCluster,
    generate_keypair,
    execute_tx,
    get_coins,
    get_balance,
    commit_preparation,
    commit_demonstration,
    run_test_cluster
}
